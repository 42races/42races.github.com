<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<link href="/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png">
<link href="favicon-96x96.png" rel="icon" sizes="96x96" type="image/png">
<link href="favicon-16x16.png" rel="icon" sizes="16x16" type="image/png">
<link href="/css/app.css" rel="stylesheet" type="text/css">
<link href="/css/default.css" rel="stylesheet" type="text/css">
<script src="/js/app.js" type="text/javascript"></script><title>Document</title>
</head>
<body><div class="container">
<div class="header">
<div class="name">Deepak Kumar</div>
<div class="links pull-right">
<a href="https://twitter.com/42races" target="_blank">Twitter</a><a href="https://twitter.com/42races" target="_blank">Github</a>
</div>
</div>
<div class="page-content">
<p>While going through <strong>rake</strong> source code I came across a function named <strong>module_function</strong>. I googled about it and came to know that it provides an easy way to create module functions where the receiver is the module itself. Take an example of a <strong><em>Sample</em></strong> module.</p>

<p>module Sample
      def random<em>string
        # generates a random string
        [('A'..'Z'), ('a'..'z'), ('0'..'9')].map(&amp;:to</em>a).reduce(:+).shuffle.take(8).join
      end</p>

<p>module<em>function :random</em>string
    end</p>

<p>Sample.random_string # =&gt;  "NMHPXydR"</p>

<p>The method <strong><em>random</em>string</strong>_ can be invoked on the module itself. If you include the module in a class then this method becomes private to that class's instance.</p>

<p>class A
      include Sample</p>

<p>def generate<em>random</em>string
        random_string    # private method call
      end
    end</p>

<p>o = A.new
    o.generate<em>random</em>string  # =&gt; "GQV1j0OK"</p>

<p>Another interesting thing about this method is the module maintains an original copy even if you override the method. In order to understand it lets take an example. Lets override the <strong><em>random</em>string</strong>_ method in the <strong><em>Sample</em></strong> module.</p>

<p>module Sample</p>

<p># override random<em>string
      def random</em>string
        # generates a random string containing only numbers
        (0..9).map(&amp;:to_s).shuffle.join
      end
    end</p>

<p>Now if you call the mehtod using on instance of class <strong><em>A</em></strong> you will get the new method</p>

<p>o.generate<em>random</em>string   # =&gt;  "8073541692"</p>

<p>But the module method is the same</p>

<p>Sample.random_string       # =&gt; "VBkj5fMd"</p>

<p>I found this is a very easy way to create module methods hope you also feel so.</p>
</div>
<div class="footer"><div class="copyright">Made with passion usingÂ <a href="https://github.com/42races/parrot" target="_blank">Parrot</a>
</div></div>
</div></body>
</html>
